variables:
  GRADLE_OPTS: "-Dorg.gradle.daemon=false"

stages:
- pre-build
- build
- test
- docker build
- deploy staging
- deploy production

before_script:
- export GRADLE_USER_HOME=`pwd`/.gradle
- export CURRENT_DATETIME=`date +"%Y%m%d-%H%M%S"`
- export PROPERTIES=./src/main/resources/application.properties

pre-build:
  rules:
  - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
  - if: $CI_COMMIT_BRANCH == 'dev'
  - if: $CI_COMMIT_BRANCH == 'main'
  image: ubuntu:latest
  stage: pre-build
  tags: [e4l-server]
  script: apt-get update; apt-get --yes install gettext moreutils;envsubst < $PROPERTIES | sponge $PROPERTIES
  cache:
    key: "$CI_COMMIT_REF_NAME"
    policy: push
    paths:
    - build
    - .gradle
  artifacts:
    paths:
      - src/main/resources/application.properties


build:
  rules:
  - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
  - if: $CI_COMMIT_BRANCH == 'dev'
  - if: $CI_COMMIT_BRANCH == 'main'
  image: gradle:8.3
  stage: build
  tags: [e4l-server]
  script: gradle --build-cache clean build bootJar
  cache:
    key: "$CI_COMMIT_REF_NAME"
    policy: push
    paths:
    - build
    - .gradle

test:
  rules:
  - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
  - if: $CI_COMMIT_BRANCH == 'dev'
  - if: $CI_COMMIT_BRANCH == 'main'
  image: gradle:8.3
  stage: test
  tags: [e4l-server]
  script: gradle clean check
  cache:
    key: "$CI_COMMIT_REF_NAME"
    policy: pull
    paths:
    - build
    - .gradle

docker:
  rules:
  - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
  - if: $CI_COMMIT_BRANCH == 'dev'
  - if: $CI_COMMIT_BRANCH == 'main'
  image: docker:latest
  stage: docker build
  tags: [e4l-server]
  script:
  - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" $CI_REGISTRY
  - |
    if [ "$CI_COMMIT_BRANCH" == "dev" ]; then
      docker build --pull -t "$STAGE_CI_REGISTRY_IMAGE:latest" .
      docker push "$STAGE_CI_REGISTRY_IMAGE:latest"
    elif [ "$CI_COMMIT_BRANCH" == "main" ]; then
      docker build --pull -t "$PROD_CI_REGISTRY_IMAGE:latest" .
      docker push "$PROD_CI_REGISTRY_IMAGE:latest"
    fi
  cache:
    key: "$CI_COMMIT_REF_NAME"
    policy: pull
    paths:
    - build
    - .gradle


deploy_staging:
  stage: deploy staging
  image: alpine:3.20
  tags: [juno]
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == 'dev'

  before_script:
    - apk add --no-cache openssh-client bash coreutils curl
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    # key iz GitLab variable (multiline) -> strip CR + dodaj newline
    - printf '%s\n' "$STAGE_SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/id_ed25519
    - chmod 600 ~/.ssh/id_ed25519
    - printf "Host *\n\tStrictHostKeyChecking no\n\tUserKnownHostsFile=/dev/null\n" > ~/.ssh/config

  script:
    - |
      STAGE_HOST_CLEAN="$(printf '%s' "$STAGE_HOST" | tr -d '\r\n')"
      STAGE_USER_CLEAN="$(printf '%s' "$STAGE_USER" | tr -d '\r\n')"
      STAGE_PORT_CLEAN="$(printf '%s' "$STAGE_SSH_PORT" | tr -d '\r\n')"

      ssh -p "$STAGE_PORT_CLEAN" "$STAGE_USER_CLEAN@$STAGE_HOST_CLEAN" 'bash -s' <<'REMOTE'
      set -euo pipefail

      cd /opt/e4l

      # 1) Ensure Docker Compose v2 exists (user-space install, no sudo)
      if ! docker compose version >/dev/null 2>&1; then
        echo "Installing docker compose v2 (user-space)..."
        mkdir -p ~/.docker/cli-plugins
        ARCH="$(uname -m)"
        case "$ARCH" in
          x86_64) ARCH="x86_64" ;;
          aarch64|arm64) ARCH="aarch64" ;;
          *) echo "Unsupported arch: $ARCH"; exit 1 ;;
        esac
        COMPOSE_VERSION="v2.24.7"
        curl -fsSL "https://github.com/docker/compose/releases/download/${COMPOSE_VERSION}/docker-compose-linux-${ARCH}" \
          -o ~/.docker/cli-plugins/docker-compose
        chmod +x ~/.docker/cli-plugins/docker-compose
      fi

      docker compose version

      # 2) Load envs (compose will read env files anyway, but keep it consistent)
      set -a
      source .env
      source backend.env
      set +a

      # 3) Deploy (compose v2)
      docker compose -f docker-compose.db.yml up -d --remove-orphans
      docker compose -f docker-compose.backend.staging.yml pull
      docker compose -f docker-compose.backend.staging.yml up -d --remove-orphans

      docker ps
      REMOTE

  environment:
    name: staging

deploy_production:
  stage: deploy production
  image: alpine:3.20
  tags: [juno]
  rules:
    - if: $CI_COMMIT_BRANCH == 'main'

  before_script:
    - apk add --no-cache openssh-client bash coreutils curl
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    # key iz GitLab variable (multiline) -> strip CR + dodaj newline
    - printf '%s\n' "$PROD_SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/id_ed25519
    - chmod 600 ~/.ssh/id_ed25519
    - printf "Host *\n\tStrictHostKeyChecking no\n\tUserKnownHostsFile=/dev/null\n" > ~/.ssh/config

  script:
    - |
      PROD_HOST_CLEAN="$(printf '%s' "$PROD_HOST" | tr -d '\r\n')"
      PROD_USER_CLEAN="$(printf '%s' "$PROD_USER" | tr -d '\r\n')"
      PROD_PORT_CLEAN="$(printf '%s' "$PROD_SSH_PORT" | tr -d '\r\n')"

      ssh -p "$PROD_PORT_CLEAN" "$PROD_USER_CLEAN@$PROD_HOST_CLEAN" 'bash -s' <<'REMOTE'
      set -euo pipefail

      cd /opt/e4l-prod

      # 1) Ensure Docker Compose v2 exists (user-space install, no sudo)
      if ! docker compose version >/dev/null 2>&1; then
        echo "Installing docker compose v2 (user-space)..."
        mkdir -p ~/.docker/cli-plugins
        ARCH="$(uname -m)"
        case "$ARCH" in
          x86_64) ARCH="x86_64" ;;
          aarch64|arm64) ARCH="aarch64" ;;
          *) echo "Unsupported arch: $ARCH"; exit 1 ;;
        esac
        COMPOSE_VERSION="v2.24.7"
        curl -fsSL "https://github.com/docker/compose/releases/download/${COMPOSE_VERSION}/docker-compose-linux-${ARCH}" \
          -o ~/.docker/cli-plugins/docker-compose
        chmod +x ~/.docker/cli-plugins/docker-compose
      fi

      docker compose version

      # 2) Load envs (compose will read env files anyway, but keep it consistent)
      set -a
      source .env
      source backend.env
      set +a

      # 3) Deploy (compose v2)
      docker compose -f docker-compose.db.yml up -d --remove-orphans
      docker compose -f docker-compose.backend.prod.yml pull
      docker compose -f docker-compose.backend.prod.yml up -d --remove-orphans

      docker ps
      REMOTE

  environment:
    name: production