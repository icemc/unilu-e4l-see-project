variables:
  GRADLE_OPTS: "-Dorg.gradle.daemon=false"

stages:
- pre-build
- build
- test
- docker build
- deploy staging
- acceptance-tests
- docker build production
- deploy production

before_script:
- export GRADLE_USER_HOME=`pwd`/.gradle
- export CURRENT_DATETIME=`date +"%Y%m%d-%H%M%S"`
- export PROPERTIES=./src/main/resources/application.properties

pre-build:
  rules:
  - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
  - if: $CI_COMMIT_BRANCH == 'dev'
  - if: $CI_COMMIT_BRANCH == 'main'
  image: ubuntu:latest
  stage: pre-build
  tags: [e4l-server]
  script: apt-get update; apt-get --yes install gettext moreutils;envsubst < $PROPERTIES | sponge $PROPERTIES
  cache:
    key: "$CI_COMMIT_REF_NAME"
    policy: push
    paths:
    - build
    - .gradle
  artifacts:
    paths:
      - src/main/resources/application.properties


build:
  rules:
  - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
  - if: $CI_COMMIT_BRANCH == 'dev'
  - if: $CI_COMMIT_BRANCH == 'main'
  image: gradle:8.3
  stage: build
  tags: [e4l-server]
  script: gradle --build-cache clean build bootJar
  cache:
    key: "$CI_COMMIT_REF_NAME"
    policy: push
    paths:
    - build
    - .gradle
  artifacts:
    paths:
      - build/libs/*.jar
    expire_in: 1 hour

unit_test:
  rules:
  - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
  - if: $CI_COMMIT_BRANCH == 'dev'
  - if: $CI_COMMIT_BRANCH == 'main'
  image: gradle:8.3
  stage: test
  tags: [e4l-server]
  script: gradle test
  cache:
    key: "$CI_COMMIT_REF_NAME"
    policy: pull
    paths:
    - build
    - .gradle
  artifacts:
    when: always
    reports:
      junit: build/test-results/test/**/TEST-*.xml
    paths:
      - build/test-results/
      - build/reports/tests/
    expire_in: 1 week

integration_tests:
  needs: ["unit_test"]
  rules:
  - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
  - if: $CI_COMMIT_BRANCH == 'dev'
  - if: $CI_COMMIT_BRANCH == 'main'
  image: gradle:8.3
  stage: test
  tags: [e4l-server]
  script: gradle integrationTest
  cache:
    key: "$CI_COMMIT_REF_NAME"
    policy: pull
    paths:
    - build
    - .gradle
  artifacts:
    when: always
    reports:
      junit: build/test-results/integrationTest/**/TEST-*.xml
    paths:
      - build/test-results/
      - build/reports/tests/
    expire_in: 1 week

docker:
  rules:
  - if: $CI_PIPELINE_SOURCE == 'merge_request_event'
  - if: $CI_COMMIT_BRANCH == 'dev'
  - if: $CI_COMMIT_BRANCH == 'main'
  image: docker:latest
  stage: docker build
  tags: [e4l-server]
  needs:
    - job: build
      artifacts: true
    - job: integration_tests
  script:
  - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" $CI_REGISTRY
  # Build and push staging image only
  - docker build --pull -t "$STAGE_CI_REGISTRY_IMAGE:latest" .
  - docker push "$STAGE_CI_REGISTRY_IMAGE:latest"


deploy_staging:
  stage: deploy staging
  image: alpine:3.20
  tags: [e4l-server]
  needs: ["docker"]
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == 'dev'
    - if: $CI_COMMIT_BRANCH == 'main'

  before_script:
    - apk add --no-cache openssh-client
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - |
      printf '%s\n' "$STAGE_SSH_PRIVATE_KEY" \
      | sed 's/\r//g' \
      | sed '/^[[:space:]]*$/d' \
      > ~/.ssh/id_ed25519
    - chmod 600 ~/.ssh/id_ed25519
    - printf "Host *\n\tStrictHostKeyChecking no\n\tUserKnownHostsFile=/dev/null\n" > ~/.ssh/config

  script:
    - |
      set -euo pipefail

      STAGE_HOST_CLEAN="$(printf '%s' "$STAGE_HOST" | tr -d '\r\n')"
      STAGE_USER_CLEAN="$(printf '%s' "$STAGE_USER" | tr -d '\r\n')"
      STAGE_PORT_CLEAN="$(printf '%s' "$STAGE_SSH_PORT" | tr -d '\r\n')"
      STAGE_PATH_CLEAN="$(printf '%s' "$STAGE_PATH" | tr -d '\r\n')"

      # Create backend directory structure on VM
      ssh -p "$STAGE_PORT_CLEAN" "$STAGE_USER_CLEAN@$STAGE_HOST_CLEAN" \
        "mkdir -p '$STAGE_PATH_CLEAN/docker'"

      # Upload docker-compose files to VM
      scp -P "$STAGE_PORT_CLEAN" docker/docker-compose.db.yml \
        "$STAGE_USER_CLEAN@$STAGE_HOST_CLEAN:$STAGE_PATH_CLEAN/docker/docker-compose.db.yml"
      
      scp -P "$STAGE_PORT_CLEAN" docker/docker-compose.backend.staging.yml \
        "$STAGE_USER_CLEAN@$STAGE_HOST_CLEAN:$STAGE_PATH_CLEAN/docker/docker-compose.backend.staging.yml"

      # Deploy: login to docker.io + pull + up
      ssh -p "$STAGE_PORT_CLEAN" "$STAGE_USER_CLEAN@$STAGE_HOST_CLEAN" \
        "set -euo pipefail;
         cd '$STAGE_PATH_CLEAN/docker';
         echo '$CI_REGISTRY_PASSWORD' | docker login -u '$CI_REGISTRY_USER' --password-stdin '$CI_REGISTRY';
         export BACKEND_IMAGE='${STAGE_CI_REGISTRY_IMAGE}';
         export MYSQL_USERNAME='e4l';
         export MYSQL_PASSWORD='e4lpassword';
         export MYSQL_ROOT_PASSWORD='rootpassword';
         export DUMP_DIR='/opt/dumps';
         
         # Check if database is already running (from setup_envs.sh)
         if ! docker ps | grep -q e4l-db; then
           echo 'Starting database container...';
           docker compose -f docker-compose.db.yml up -d --remove-orphans;
         else
           echo 'Database container already running, skipping...';
         fi
         
         docker compose -f docker-compose.backend.staging.yml pull;
         docker compose -f docker-compose.backend.staging.yml up -d --remove-orphans;
         docker ps --format 'table {{.Names}}\t{{.Image}}\t{{.Status}}' | grep -E 'e4l-backend-staging|db' || true"

  environment:
    name: staging

e2e_acceptance_tests:
  stage: acceptance-tests
  image: docker:29.0.1
  tags: [e4l-server]
  needs: ["deploy_staging"]
  rules:
    - if: $CI_COMMIT_BRANCH == 'main'
  
  variables:
    STAGING_API_URL: "http://192.168.56.11:8084"
  
  script:
    # 1. Update Postman environment to point to staging backend VM
    - sed -i "s|http://localhost:8084|$STAGING_API_URL|g" tests/postman/staging.environment.json
    
    # 2. Wait for backend to be fully ready before testing
    - echo "Waiting for staging backend to be ready..."
    - |
      docker run --rm curlimages/curl:latest \
        --fail --retry 15 --retry-delay 5 --retry-connrefused \
        http://192.168.56.11:8084/e4lapi/questionnaire
    
    # 3. Create Newman container (not started yet)
    - docker create --name "newman-$CI_JOB_ID" postman/newman:5-alpine run /etc/newman/e4l-backend-e2e.collection.json -e /etc/newman/staging.environment.json
    
    # 4. Copy test files into the container
    - docker cp "$CI_PROJECT_DIR/tests/postman/." "newman-$CI_JOB_ID:/etc/newman/"
    
    # 5. Run the E2E tests
    - docker start -a "newman-$CI_JOB_ID"
  
  after_script:
    # Cleanup: remove Newman container
    - docker rm -f "newman-$CI_JOB_ID" || true

docker_build_production:
  stage: docker build production
  image: docker:latest
  tags: [e4l-server]
  needs:
    - job: build
      artifacts: true
    - job: e2e_acceptance_tests
  rules:
    - if: $CI_COMMIT_BRANCH == 'main'
  script:
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" $CI_REGISTRY
    # Build and push production image ONLY if E2E tests passed
    - docker build --pull -t "$PROD_CI_REGISTRY_IMAGE:release" .
    - docker push "$PROD_CI_REGISTRY_IMAGE:release"

deploy_production:
  stage: deploy production
  image: alpine:3.20
  tags: [e4l-server]
  needs: ["docker_build_production"]
  rules:
    - if: $CI_COMMIT_BRANCH == 'main'

  before_script:
    - apk add --no-cache openssh-client
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - |
      printf '%s\n' "$PROD_SSH_PRIVATE_KEY" \
      | sed 's/\r//g' \
      | sed '/^[[:space:]]*$/d' \
      > ~/.ssh/id_ed25519
    - chmod 600 ~/.ssh/id_ed25519
    - printf "Host *\n\tStrictHostKeyChecking no\n\tUserKnownHostsFile=/dev/null\n" > ~/.ssh/config

  script:
    - |
      set -euo pipefail

      PROD_HOST_CLEAN="$(printf '%s' "$PROD_HOST" | tr -d '\r\n')"
      PROD_USER_CLEAN="$(printf '%s' "$PROD_USER" | tr -d '\r\n')"
      PROD_PORT_CLEAN="$(printf '%s' "$PROD_SSH_PORT" | tr -d '\r\n')"
      PROD_PATH_CLEAN="$(printf '%s' "$PROD_PATH" | tr -d '\r\n')"

      # Create backend directory structure on VM
      ssh -p "$PROD_PORT_CLEAN" "$PROD_USER_CLEAN@$PROD_HOST_CLEAN" \
        "mkdir -p '$PROD_PATH_CLEAN/docker'"

      # Upload docker-compose files to VM
      scp -P "$PROD_PORT_CLEAN" docker/docker-compose.db.yml \
        "$PROD_USER_CLEAN@$PROD_HOST_CLEAN:$PROD_PATH_CLEAN/docker/docker-compose.db.yml"
      
      scp -P "$PROD_PORT_CLEAN" docker/docker-compose.backend.prod.yml \
        "$PROD_USER_CLEAN@$PROD_HOST_CLEAN:$PROD_PATH_CLEAN/docker/docker-compose.backend.prod.yml"

      # Deploy: login to docker.io + pull + up
      ssh -p "$PROD_PORT_CLEAN" "$PROD_USER_CLEAN@$PROD_HOST_CLEAN" \
        "set -euo pipefail;
         cd '$PROD_PATH_CLEAN/docker';
         echo '$CI_REGISTRY_PASSWORD' | docker login -u '$CI_REGISTRY_USER' --password-stdin '$CI_REGISTRY';
         export BACKEND_IMAGE='${PROD_CI_REGISTRY_IMAGE}';
         export MYSQL_USERNAME='e4l';
         export MYSQL_PASSWORD='e4lpassword';
         export MYSQL_ROOT_PASSWORD='rootpassword';
         export DUMP_DIR='/opt/dumps';
         
         # Check if database is already running (from setup_envs.sh)
         if ! docker ps | grep -q e4l-db; then
           echo 'Starting database container...';
           docker compose -f docker-compose.db.yml up -d --remove-orphans;
         else
           echo 'Database container already running, skipping...';
         fi
         
         docker compose -f docker-compose.backend.prod.yml pull;
         docker compose -f docker-compose.backend.prod.yml up -d --remove-orphans;
         docker ps --format 'table {{.Names}}\t{{.Image}}\t{{.Status}}' | grep -E 'e4l-backend-prod|db' || true"

  environment:
    name: production