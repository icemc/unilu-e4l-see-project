stages:
  - build
  - test
  - docker_build_staging
  - deploy_staging
  - acceptance_tests
  - docker_build_production
  - deploy_production

.before_npm: &before_npm
  before_script:
    - npm ci --cache .npm --prefer-offline

build:
  stage: build
  image: node:16
  tags: [juno]
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "dev"'
    - if: '$CI_COMMIT_BRANCH == "main"'
  <<: *before_npm
  script:
    - npm run build
  artifacts:
    paths:
      - e4l.frontend.docker/web/dist/
    expire_in: 1 hour
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - .npm/

# Unit tests
unit_tests:
  stage: test
  image: node:16
  tags: [juno]
  needs: ["build"]
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "dev"'
    - if: '$CI_COMMIT_BRANCH == "main"'
  <<: *before_npm
  script:
    - npm run test:unit:ci
  artifacts:
    when: always
    reports:
      junit: coverage/junit-unit.xml
    paths:
      - coverage/
    expire_in: 1 week

# Integration tests
integration_tests:
  stage: test
  image: node:16
  tags: [juno]
  needs: ["unit_tests"]
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "dev"'
    - if: '$CI_COMMIT_BRANCH == "main"'
  <<: *before_npm
  script:
    - npm run test:integration:ci
  artifacts:
    when: always
    reports:
      junit: coverage/junit-integration.xml
    paths:
      - coverage/
    expire_in: 1 week

docker_build_staging_frontend:
  stage: docker_build_staging
  image: docker:24
  tags: [juno]
  needs: ["integration_tests"]
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "dev"'
    - if: '$CI_COMMIT_BRANCH == "main"'
  script:
    - docker version

    # Docker Hub login (CI_REGISTRY=docker.io)
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"

    # Build + push staging image
    - docker build --build-arg API_URL=/API_URL --build-arg PUBLIC_PATH=/ -t "$STAGE_CI_REGISTRY_IMAGE:latest" -f e4l.frontend.docker/web/Dockerfile .
    - docker push "$STAGE_CI_REGISTRY_IMAGE:latest"

deploy_staging_frontend:
  stage: deploy_staging
  image: alpine:3.20
  tags: [juno]
  needs: ["docker_build_staging_frontend"]
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "dev"'
    - if: '$CI_COMMIT_BRANCH == "main"'

  before_script:
    - apk add --no-cache openssh-client
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - |
      printf '%s\n' "$STAGE_SSH_PRIVATE_KEY" \
      | sed 's/\r//g' \
      | sed '/^[[:space:]]*$/d' \
      > ~/.ssh/id_ed25519
    - chmod 600 ~/.ssh/id_ed25519
    - printf "Host *\n\tStrictHostKeyChecking no\n\tUserKnownHostsFile=/dev/null\n" > ~/.ssh/config

  script:
    - |
      set -euo pipefail

      STAGE_HOST_CLEAN="$(printf '%s' "$STAGE_HOST" | tr -d '\r\n')"
      STAGE_USER_CLEAN="$(printf '%s' "$STAGE_USER" | tr -d '\r\n')"
      STAGE_PORT_CLEAN="$(printf '%s' "$STAGE_SSH_PORT" | tr -d '\r\n')"
      STAGE_PATH_CLEAN="$(printf '%s' "$STAGE_PATH" | tr -d '\r\n')"

      # Stavi compose na VM (isti layout kao što si ručno koristio)
      ssh -p "$STAGE_PORT_CLEAN" "$STAGE_USER_CLEAN@$STAGE_HOST_CLEAN" \
        "mkdir -p '$STAGE_PATH_CLEAN/e4l.frontend.docker'"

      scp -P "$STAGE_PORT_CLEAN" e4l.frontend.docker/docker-compose.frontend.staging.yml \
        "$STAGE_USER_CLEAN@$STAGE_HOST_CLEAN:$STAGE_PATH_CLEAN/e4l.frontend.docker/docker-compose.frontend.staging.yml"

      # Deploy: login na docker.io + pull + up
      ssh -p "$STAGE_PORT_CLEAN" "$STAGE_USER_CLEAN@$STAGE_HOST_CLEAN" \
        "set -euo pipefail;
         cd '$STAGE_PATH_CLEAN/e4l.frontend.docker';
         echo '$CI_REGISTRY_PASSWORD' | docker login -u '$CI_REGISTRY_USER' --password-stdin '$CI_REGISTRY';
         export FRONTEND_IMAGE='${STAGE_CI_REGISTRY_IMAGE}';
         docker compose -f docker-compose.frontend.staging.yml pull;
         docker compose -f docker-compose.frontend.staging.yml up -d --remove-orphans;
         docker ps --format 'table {{.Names}}\t{{.Image}}\t{{.Status}}' | grep e4l-frontend-staging || true"

acceptance_tests:
  stage: acceptance_tests
  image: node:16
  tags: [juno]
  needs: ["deploy_staging_frontend"]
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
  
  variables:
    E2E_BASE_URL: "http://192.168.56.11:8082"
  
  <<: *before_npm
  
  before_script:
    - npm ci --cache .npm --prefer-offline
    # Wait for staging frontend to be ready
    - |
      apt-get update && apt-get install -y curl
      echo "Waiting for staging frontend to be ready..."
      for i in $(seq 1 30); do
        if curl -f "$E2E_BASE_URL" > /dev/null 2>&1; then
          echo "✓ Staging frontend is ready at $E2E_BASE_URL"
          break
        fi
        echo "Waiting... ($i/30)"
        sleep 2
      done
  
  script:
    - npm run test:e2e:ci
  
  artifacts:
    when: always
    reports:
      junit: coverage/junit-e2e.xml
    paths:
      - coverage/
    expire_in: 1 week

docker_build_production_frontend:
  stage: docker_build_production
  image: docker:24
  tags: [juno]
  needs: ["acceptance_tests"]
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
  script:
    - docker version

    # Docker Hub login (CI_REGISTRY=docker.io)
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"

    # Build + push production image
    - docker build --build-arg API_URL=/API_URL --build-arg PUBLIC_PATH=/ -t "$PROD_CI_REGISTRY_IMAGE:release" -f e4l.frontend.docker/web/Dockerfile .
    - docker push "$PROD_CI_REGISTRY_IMAGE:release"

deploy_production_frontend:
  stage: deploy_production
  image: alpine:3.20
  tags: [juno]
  needs: ["docker_build_production_frontend"]
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'

  before_script:
    - apk add --no-cache openssh-client
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - |
      printf '%s\n' "$PROD_SSH_PRIVATE_KEY" \
      | sed 's/\r//g' \
      | sed '/^[[:space:]]*$/d' \
      > ~/.ssh/id_ed25519
    - chmod 600 ~/.ssh/id_ed25519
    - printf "Host *\n\tStrictHostKeyChecking no\n\tUserKnownHostsFile=/dev/null\n" > ~/.ssh/config

  script:
    - |
      set -euo pipefail

      PROD_HOST_CLEAN="$(printf '%s' "$PROD_HOST" | tr -d '\r\n')"
      PROD_USER_CLEAN="$(printf '%s' "$PROD_USER" | tr -d '\r\n')"
      PROD_PORT_CLEAN="$(printf '%s' "$PROD_SSH_PORT" | tr -d '\r\n')"
      PROD_PATH_CLEAN="$(printf '%s' "$PROD_PATH" | tr -d '\r\n')"

      # Stavi compose na VM
      ssh -p "$PROD_PORT_CLEAN" "$PROD_USER_CLEAN@$PROD_HOST_CLEAN" \
        "mkdir -p '$PROD_PATH_CLEAN/e4l.frontend.docker'"

      scp -P "$PROD_PORT_CLEAN" e4l.frontend.docker/docker-compose.frontend.prod.yml \
        "$PROD_USER_CLEAN@$PROD_HOST_CLEAN:$PROD_PATH_CLEAN/e4l.frontend.docker/docker-compose.frontend.prod.yml"

      # Deploy: login na docker.io + pull + up
      ssh -p "$PROD_PORT_CLEAN" "$PROD_USER_CLEAN@$PROD_HOST_CLEAN" \
        "set -euo pipefail;
         cd '$PROD_PATH_CLEAN/e4l.frontend.docker';
         echo '$CI_REGISTRY_PASSWORD' | docker login -u '$CI_REGISTRY_USER' --password-stdin '$CI_REGISTRY';
         export FRONTEND_IMAGE='${PROD_CI_REGISTRY_IMAGE}';
         docker compose -f docker-compose.frontend.prod.yml pull;
         docker compose -f docker-compose.frontend.prod.yml up -d --remove-orphans;
         docker ps --format 'table {{.Names}}\t{{.Image}}\t{{.Status}}' | grep e4l-frontend-prod || true"
