================================================================================
                    E4L Platform - Test Scenarios
================================================================================

This document demonstrates the DevOps workflow with branch-based deployments
and automated CI/CD pipelines. Each scenario shows how to trigger deployments
and observe the pipeline execution.


DEVOPS STRATEGY OVERVIEW
================================================================================

Branching Strategy:
- dev branch  → Automatically deploys to STAGING (192.168.56.11)
- main branch → Automatically deploys to PRODUCTION (192.168.56.12)

Pipeline Structure:
- Backend:  6 stages (pre-build, build, test, docker_build, deploy_staging, deploy_production)
- Frontend: 3 stages (docker_build, deploy_staging, deploy_production)

Deployment Method:
- Docker images pushed to Docker Hub (docker.io/minfranco)
- SSH deployment to Vagrant VMs
- docker-compose pull and up commands executed on target VMs


================================================================================
BACKEND PIPELINE SCENARIOS
================================================================================


# Scenario 1: Backend Build and Test - PASSING

## Goal
Verify that backend builds successfully and tests pass in the CI/CD pipeline.

## Pre-conditions
- GitLab is up and running at http://localhost:8929
- GitLab Runner is registered and active
- Backend repository has been seeded with source code
- You are on the dev branch

## Main Success Scenario
1. Make a small code change (e.g., add a comment in a Java file)
2. Commit and push to dev branch:
   ```
   git add .
   git commit -m "Test backend pipeline"
   git push origin dev
   ```
3. Go to: http://localhost:8929/testdev/backend/-/pipelines
4. Click on the latest pipeline
5. Observe stages execute in order:
   - pre-build (green checkmark)
   - build (green checkmark) - Gradle builds the JAR
   - test (green checkmark) - JUnit tests run
   - docker_build (green checkmark) - Docker image built and pushed
   - deploy_staging (green checkmark) - Deployed to 192.168.56.11

## Expected Result
- All stages pass successfully
- Docker image pushed as: minfranco/e4l-backend-stage:latest
- Backend running at http://localhost:8084

## Verification
- Visit http://localhost:8084 to see backend API
- SSH to staging VM: `ssh -i ~/.ssh/devops_stage vagrant@192.168.56.11 -p 2222`
- Check containers: `docker ps` (should see e4l-backend container)

--------------------------------------------------------------------------------

# Scenario 2: Backend Build - FAILING

## Goal
Demonstrate that the pipeline fails when the build fails.

## Pre-conditions
- GitLab is up and running at http://localhost:8929
- Backend repository has been seeded with source code
- User is logged in as testdev

## Main Success Scenario
1. Go to: http://localhost:8929/testdev/backend
2. Navigate to any Java file (e.g., src/main/java/lu/uni/e4l/platform/...)
3. Click "Edit" → "Edit single file"
4. Introduce a syntax error (e.g., remove a semicolon or add invalid code):
   ```java
   // Add this invalid line
   this is not valid Java code
   ```
5. Commit changes to dev branch (triggers pipeline)
6. Go to: http://localhost:8929/testdev/backend/-/pipelines
7. Observe pipeline fails at "build" stage (red X)
8. View logs to see Gradle compilation error

## Restore
Remove the syntax error and commit to restore.

--------------------------------------------------------------------------------

# Scenario 3: Backend Deployment to Staging (dev branch)

## Goal
Demonstrate automatic deployment to staging environment when pushing to dev branch.

## Pre-conditions
- GitLab is up and running at http://localhost:8929
- Staging VM is running (192.168.56.11)
- Backend repository has working code
- You are on the dev branch

## Main Success Scenario
1. Make a visible change (e.g., modify application.properties):
   ```properties
   # Add or modify a property
   app.environment=staging-test-v2
   ```
2. Commit and push to dev branch:
   ```
   git add .
   git commit -m "Update staging environment"
   git push origin dev
   ```
3. Go to: http://localhost:8929/testdev/backend/-/pipelines
4. Watch pipeline execute all stages
5. Observe "deploy_staging" stage executes (green checkmark)
6. Note that "deploy_production" stage is skipped (only runs on main branch)

## Expected Result
- Pipeline completes successfully
- deploy_staging stage shows SSH connection to 192.168.56.11
- Backend redeployed at http://localhost:8084

## Verification
- Visit http://localhost:8084 to verify new version
- Check pipeline logs for: "Deploying to STAGING (192.168.56.11)"
- SSH to VM and check: `docker logs e4l-backend`

--------------------------------------------------------------------------------

# Scenario 4: Backend Deployment to Production (main branch)

## Goal
Demonstrate automatic deployment to production environment when pushing to main branch.

## Pre-conditions
- GitLab is up and running at http://localhost:8929
- Production VM is running (192.168.56.12)
- Backend repository has tested code on dev branch
- You have working code on dev branch

## Main Success Scenario
1. Switch to main branch:
   ```
   git checkout main
   git pull origin main
   ```
2. Merge dev branch into main:
   ```
   git merge dev
   ```
3. Push to main branch:
   ```
   git push origin main
   ```
4. Go to: http://localhost:8929/testdev/backend/-/pipelines
5. Watch pipeline execute all stages
6. Observe "deploy_production" stage executes (green checkmark)
7. Note that "deploy_staging" stage is skipped (only runs on dev branch)

## Expected Result
- Pipeline completes successfully
- deploy_production stage shows SSH connection to 192.168.56.12
- Backend redeployed at http://localhost:8085
- Docker image tagged as: minfranco/e4l-backend-prod:latest

## Verification
- Visit http://localhost:8085 to verify production deployment
- Check pipeline logs for: "Deploying to PRODUCTION (192.168.56.12)"
- SSH to VM: `ssh -i ~/.ssh/devops_prod vagrant@192.168.56.12 -p 2223`
- Check containers: `docker ps`

--------------------------------------------------------------------------------

# Scenario 5: Backend Test Failure Prevention

## Goal
Demonstrate that failing tests prevent deployment.

## Pre-conditions
- GitLab is up and running at http://localhost:8929
- Backend repository has test files
- User is logged in as testdev

## Main Success Scenario
1. Go to: http://localhost:8929/testdev/backend
2. Navigate to a test file in src/test/java/
3. Click "Edit" → "Edit single file"
4. Modify a test to fail (e.g., change an assertion):
   ```java
   // Change an assertEquals to an incorrect value
   assertEquals(999, actualValue);
   ```
5. Commit changes to dev branch
6. Go to: http://localhost:8929/testdev/backend/-/pipelines
7. Observe pipeline fails at "test" stage (red X)
8. Verify that docker_build and deploy_staging stages never run

## Expected Result
- Pipeline stops at test stage
- No deployment occurs
- Staging environment remains unchanged

## Restore
Fix the test assertion and commit to restore pipeline.


================================================================================
FRONTEND PIPELINE SCENARIOS
================================================================================

# Scenario 6: Frontend Docker Build and Deploy - PASSING

## Goal
Verify that frontend builds successfully and deploys to staging.

## Pre-conditions
- GitLab is up and running at http://localhost:8929
- GitLab Runner is registered and active
- Frontend repository has been seeded with source code
- You are on the dev branch

## Main Success Scenario
1. Make a small change to frontend code (e.g., modify a CSS file or component)
2. Commit and push to dev branch:
   ```
   git add .
   git commit -m "Test frontend pipeline"
   git push origin dev
   ```
3. Go to: http://localhost:8929/testdev/frontend/-/pipelines
4. Click on the latest pipeline
5. Observe stages execute in order:
   - docker_build (green checkmark) - Docker image built and pushed
   - deploy_staging (green checkmark) - Deployed to 192.168.56.11

## Expected Result
- All stages pass successfully
- Docker image pushed as: minfranco/e4l-frontend-stage:latest
- Frontend running at http://localhost:8881

## Verification
- Visit http://localhost:8881 to see frontend application
- SSH to staging VM: `ssh -i ~/.ssh/devops_stage vagrant@192.168.56.11 -p 2222`
- Check containers: `docker ps` (should see e4l-frontend container)

--------------------------------------------------------------------------------

# Scenario 7: Frontend Docker Build - FAILING

## Goal
Demonstrate that the pipeline fails when the Docker build fails.

## Pre-conditions
- GitLab is up and running at http://localhost:8929
- Frontend repository has been seeded with source code
- User is logged in as testdev

## Main Success Scenario
1. Go to: http://localhost:8929/testdev/frontend
2. Navigate to: Dockerfile (in e4l.frontend.docker/web/)
3. Click "Edit" → "Edit single file"
4. Introduce an error in Dockerfile:
   ```dockerfile
   # Add an invalid instruction
   INVALID_COMMAND this will cause build to fail
   ```
5. Commit changes to dev branch (triggers pipeline)
6. Go to: http://localhost:8929/testdev/frontend/-/pipelines
7. Observe pipeline fails at "docker_build" stage (red X)
8. View logs to see Docker build error

## Restore
Remove the invalid instruction and commit to restore.

--------------------------------------------------------------------------------

# Scenario 8: Frontend Deployment to Staging (dev branch)

## Goal
Demonstrate automatic deployment to staging environment when pushing to dev branch.

## Pre-conditions
- GitLab is up and running at http://localhost:8929
- Staging VM is running (192.168.56.11)
- Frontend repository has working code
- You are on the dev branch

## Main Success Scenario
1. Make a visible UI change (e.g., modify src/index.html or CSS):
   ```html
   <!-- Add a comment or change page title -->
   <title>E4L Platform - Staging Test v2</title>
   ```
2. Commit and push to dev branch:
   ```
   git add .
   git commit -m "Update staging frontend"
   git push origin dev
   ```
3. Go to: http://localhost:8929/testdev/frontend/-/pipelines
4. Watch pipeline execute all stages
5. Observe "deploy_staging" stage executes (green checkmark)
6. Note that "deploy_production" stage is skipped (only runs on main branch)

## Expected Result
- Pipeline completes successfully
- deploy_staging stage shows SSH connection to 192.168.56.11
- Frontend redeployed at http://localhost:8881

## Verification
- Visit http://localhost:8881 to verify new version
- Check browser page title or UI changes
- Check pipeline logs for: "Deploying to STAGING (192.168.56.11)"

--------------------------------------------------------------------------------

# Scenario 9: Frontend Deployment to Production (main branch)

## Goal
Demonstrate automatic deployment to production environment when pushing to main branch.

## Pre-conditions
- GitLab is up and running at http://localhost:8929
- Production VM is running (192.168.56.12)
- Frontend repository has tested code on dev branch
- You have working code on dev branch

## Main Success Scenario
1. Switch to main branch:
   ```
   git checkout main
   git pull origin main
   ```
2. Merge dev branch into main:
   ```
   git merge dev
   ```
3. Push to main branch:
   ```
   git push origin main
   ```
4. Go to: http://localhost:8929/testdev/frontend/-/pipelines
5. Watch pipeline execute all stages
6. Observe "deploy_production" stage executes (green checkmark)
7. Note that "deploy_staging" stage is skipped (only runs on dev branch)

## Expected Result
- Pipeline completes successfully
- deploy_production stage shows SSH connection to 192.168.56.12
- Frontend redeployed at http://localhost:8882
- Docker image tagged as: minfranco/e4l-frontend-prod:latest

## Verification
- Visit http://localhost:8882 to verify production deployment
- Check pipeline logs for: "Deploying to PRODUCTION (192.168.56.12)"
- SSH to VM: `ssh -i ~/.ssh/devops_prod vagrant@192.168.56.12 -p 2223`
- Check containers: `docker ps`

--------------------------------------------------------------------------------

# Scenario 10: Frontend Build Error in Webpack

## Goal
Demonstrate that build errors in webpack prevent deployment.

## Pre-conditions
- GitLab is up and running at http://localhost:8929
- Frontend repository has source code
- User is logged in as testdev

## Main Success Scenario
1. Go to: http://localhost:8929/testdev/frontend
2. Navigate to a JavaScript file (e.g., src/js/index.js)
3. Click "Edit" → "Edit single file"
4. Introduce a syntax error:
   ```javascript
   // Add invalid JavaScript
   import { something from 'nowhere';  // Missing closing brace
   ```
5. Commit changes to dev branch
6. Go to: http://localhost:8929/testdev/frontend/-/pipelines
7. Observe pipeline fails at "docker_build" stage (red X)
8. View logs to see webpack compilation error
9. Verify that deploy_staging stage never runs

## Expected Result
- Pipeline stops at docker_build stage
- No deployment occurs
- Staging environment remains unchanged

## Restore
Fix the syntax error and commit to restore pipeline.


================================================================================
CROSS-ENVIRONMENT SCENARIOS
================================================================================

# Scenario 11: Promote from Staging to Production

## Goal
Demonstrate the workflow of testing in staging, then promoting to production.

## Pre-conditions
- Both staging and production VMs are running
- Code is working on dev branch
- GitLab is accessible

## Main Success Scenario
1. Develop and test changes locally
2. Push to dev branch:
   ```
   git push origin dev
   ```
3. Wait for pipeline to complete
4. Verify deployment on staging:
   - Frontend: http://localhost:8881
   - Backend: http://localhost:8084
5. Test application functionality on staging
6. Once satisfied, merge to main:
   ```
   git checkout main
   git pull origin main
   git merge dev
   git push origin main
   ```
7. Wait for production pipeline to complete
8. Verify deployment on production:
   - Frontend: http://localhost:8882
   - Backend: http://localhost:8085

## Expected Result
- Staging environment gets immediate updates from dev branch
- Production environment only gets updates from main branch
- Both environments remain isolated

## Verification
- Compare versions on staging vs production
- Check Docker images: stage vs prod tags
- Verify database isolation (e4l_stage vs e4l_prod)

--------------------------------------------------------------------------------

# Scenario 12: Rollback Production Deployment

## Goal
Demonstrate how to rollback a production deployment if issues are found.

## Pre-conditions
- Production VM is running with current deployment
- Previous working version exists in Docker Hub
- GitLab is accessible

## Main Success Scenario (Git Revert Method)
1. Identify the problematic commit in main branch
2. Revert the commit:
   ```
   git revert <commit-hash>
   git push origin main
   ```
3. Pipeline automatically runs and deploys previous version
4. Verify production is back to working state

## Alternative Method (Manual Docker)
1. SSH to production VM:
   ```
   ssh -i ~/.ssh/devops_prod vagrant@192.168.56.12 -p 2223
   ```
2. Pull specific image version:
   ```
   docker pull minfranco/e4l-backend-prod:<previous-tag>
   ```
3. Update docker-compose to use specific tag
4. Restart containers:
   ```
   docker-compose up -d
   ```

## Verification
- Verify application functionality restored
- Check application version/logs
- Monitor for errors


================================================================================
MONITORING AND DEBUGGING SCENARIOS
================================================================================

# Scenario 13: View Pipeline Logs for Failed Deployment

## Goal
Debug a failed deployment by examining pipeline logs.

## Pre-conditions
- A pipeline has failed during deployment stage
- User is logged in to GitLab

## Main Success Scenario
1. Go to: http://localhost:8929/testdev/backend/-/pipelines (or frontend)
2. Click on the failed pipeline (red X)
3. Click on the failed stage (e.g., deploy_staging)
4. Examine the logs for error messages:
   - SSH connection errors
   - docker-compose errors
   - Permission issues
   - Network connectivity problems
5. Identify the root cause
6. Fix the issue and retry

## Common Errors
- SSH key permission denied → Check SSH key configuration
- docker-compose command not found → Check VM provisioning
- Cannot pull image → Check Docker Hub credentials or image name
- Port already in use → Check for conflicting containers

--------------------------------------------------------------------------------

# Scenario 14: Verify Deployment on VM

## Goal
Manually verify that deployment succeeded on the target VM.

## Pre-conditions
- Pipeline shows successful deployment
- SSH key is configured

## Main Success Scenario
1. SSH to staging VM:
   ```
   ssh -i ~/.ssh/devops_stage vagrant@192.168.56.11 -p 2222
   ```
2. Check running containers:
   ```
   docker ps
   ```
3. Verify expected containers are running:
   - e4l-backend
   - e4l-frontend
   - e4l-db
4. Check container logs:
   ```
   docker logs e4l-backend
   docker logs e4l-frontend
   docker logs e4l-db
   ```
5. Verify networking:
   ```
   docker network ls
   docker network inspect devops-net
   ```
6. Check application accessibility from VM:
   ```
   curl http://localhost:8080  # Backend
   curl http://localhost:80    # Frontend
   ```

## Expected Result
- All containers running and healthy
- Logs show no errors
- Applications responding to requests

--------------------------------------------------------------------------------

# Scenario 15: Compare Staging and Production Environments

## Goal
Verify that staging and production are properly isolated.

## Pre-conditions
- Both environments are deployed
- User has SSH access to both VMs

## Main Success Scenario
1. Check staging:
   - SSH: `ssh -i ~/.ssh/devops_stage vagrant@192.168.56.11 -p 2222`
   - Docker images: `docker images | grep e4l`
   - Database: `docker exec e4l-db mysql -u root -p -e "SHOW DATABASES;"`
2. Check production:
   - SSH: `ssh -i ~/.ssh/devops_prod vagrant@192.168.56.12 -p 2223`
   - Docker images: `docker images | grep e4l`
   - Database: `docker exec e4l-db mysql -u root -p -e "SHOW DATABASES;"`
3. Compare:
   - Different image tags (stage vs prod)
   - Different working directories (/opt/e4l vs /opt/e4l-prod)
   - Different databases (e4l_stage vs e4l_prod)
   - Different external ports (8881/8084 vs 8882/8085)

## Expected Result
- Complete isolation between environments
- Staging changes don't affect production
- Different data in each database


================================================================================
SUMMARY TABLE
================================================================================

| #  | Scenario Type         | Branch | Target Env | Outcome  | Key Learning                |
|----|-----------------------|--------|------------|----------|------------------------------|
| 1  | Backend Build         | dev    | Staging    | SUCCESS  | Pipeline stages execute      |
| 2  | Backend Build Failure | dev    | None       | FAILURE  | Build errors block pipeline  |
| 3  | Backend to Staging    | dev    | Staging    | SUCCESS  | Auto-deploy on dev push      |
| 4  | Backend to Production | main   | Production | SUCCESS  | Auto-deploy on main push     |
| 5  | Backend Test Failure  | dev    | None       | FAILURE  | Tests block deployment       |
| 6  | Frontend Build        | dev    | Staging    | SUCCESS  | Docker build and deploy      |
| 7  | Frontend Build Fail   | dev    | None       | FAILURE  | Docker errors block pipeline |
| 8  | Frontend to Staging   | dev    | Staging    | SUCCESS  | Auto-deploy on dev push      |
| 9  | Frontend to Production| main   | Production | SUCCESS  | Auto-deploy on main push     |
| 10 | Frontend Webpack Fail | dev    | None       | FAILURE  | Build errors block deploy    |
| 11 | Staging → Production  | both   | Both       | SUCCESS  | Full promotion workflow      |
| 12 | Rollback Production   | main   | Production | SUCCESS  | Recovery from bad deploy     |
| 13 | Debug Failed Deploy   | any    | Any        | DEBUG    | Troubleshooting pipelines    |
| 14 | Verify VM Deployment  | any    | Any        | VERIFY   | Manual deployment checks     |
| 15 | Environment Isolation | both   | Both       | VERIFY   | Staging vs production        |

================================================================================
